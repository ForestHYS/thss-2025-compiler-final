# SysY 编译器项目说明文档

## 项目概述

本项目是一个完整的 SysY 语言编译器实现，将 SysY 语言源代码编译生成 LLVM IR（中间表示）。该项目作为清华大学 2025 年汇编与编译原理课程（课程号：44100593）的期末项目。

### 项目基本信息

- **项目名称**: thss-2025-compiler-final
- **编程语言**: C++17
- **构建系统**: CMake 3.10+
- **解析器生成器**: ANTLR4 (v4.13.1)
- **目标输出**: LLVM IR 文本格式
- **许可证**: MIT License

### 技术栈

- **C++17**: 项目主要实现语言，使用现代 C++ 特性（如智能指针、移动语义等）
- **ANTLR4**: 用于词法和语法分析，自动生成 Lexer 和 Parser
- **LLVM IR**: 目标代码格式，以文本方式生成（不依赖 LLVM 库）
- **CMake**: 跨平台构建工具

---

## SysY 语言特性

SysY 是一个 C 语言的子集，专为教学设计，具有以下特点：

### 支持的特性

1. **基本数据类型**
   - `int`: 32位有符号整数
   - `void`: 函数返回类型

2. **变量和常量**
   - 全局变量/常量声明
   - 局部变量/常量声明
   - 常量必须初始化
   - 支持初始化列表

3. **数组**
   - 多维数组（最多支持任意维度）
   - 数组初始化（支持嵌套初始化列表）
   - 数组元素访问

4. **运算符**
   - 算术运算符: `+`, `-`, `*`, `/`, `%`
   - 关系运算符: `<`, `>`, `<=`, `>=`, `==`, `!=`
   - 逻辑运算符: `&&`, `||`, `!`
   - 一元运算符: `+`, `-`, `!`

5. **控制流**
   - 条件语句: `if-else`
   - 循环语句: `while`
   - 跳转语句: `break`, `continue`, `return`

6. **函数**
   - 函数定义和声明
   - 函数参数（支持数组参数）
   - 函数调用
   - 递归调用

7. **系统函数**
   - `getint()`: 读取整数输入
   - `getch()`: 读取字符
   - `getarray(int[])`: 读取整数数组
   - `putint(int)`: 输出整数
   - `putch(int)`: 输出字符
   - `putarray(int, int[])`: 输出整数数组
   - `starttime()`: 开始计时
   - `stoptime()`: 停止计时

---

## 编译器架构设计

编译器采用经典的多阶段编译流程，具有清晰的模块划分：

```
源代码 (.sy) 
    ↓
[词法分析] → Token流
    ↓
[语法分析] → ParseTree (ANTLR)
    ↓
[AST构建] → 抽象语法树
    ↓
[语义分析] → 符号表 + 类型检查
    ↓
[代码生成] → LLVM IR (.ll)
```

### 核心模块

#### 1. 编译器主控模块 (Compiler)

**文件**: `src/Compiler.cpp`, `include/Compiler.h`

**职责**:
- 协调各个编译阶段的执行顺序
- 管理各个模块的生命周期
- 错误处理和报告

**主要接口**:
```cpp
class Compiler {
public:
    bool compile(const std::string& inputFile, 
                const std::string& outputFile);
private:
    std::unique_ptr<CompUnitNode> parse(const std::string& inputFile);
    void semanticAnalysis(CompUnitNode* ast);
    std::string generateCode(CompUnitNode* ast);
    void outputIR(const std::string& outputFile, 
                 const std::string& irCode);
};
```

**编译流程**:
1. 调用 `parse()` 进行词法、语法分析并构建 AST
2. 调用 `semanticAnalysis()` 进行语义分析
3. 调用 `generateCode()` 生成 LLVM IR 文本
4. 调用 `outputIR()` 输出到文件

#### 2. 词法和语法分析

**文件**: `SysYLexer.g4`, `SysYParser.g4`

**使用 ANTLR4 定义**:
- **词法规则 (Lexer)**: 定义 token 类型（关键字、运算符、标识符、字面量等）
- **语法规则 (Parser)**: 定义 SysY 语言的语法结构（BNF 范式）

**生成的文件** (位于 `src/antlr/`):
- `SysYLexer.h/cpp`: 词法分析器实现
- `SysYParser.h/cpp`: 语法分析器实现
- `SysYParserBaseVisitor.h/cpp`: 访问者模式基类

**关键词法 Token**:
```antlr
CONST, INT, VOID, IF, ELSE, WHILE, BREAK, CONTINUE, RETURN
PLUS(+), MINUS(-), MUL(*), DIV(/), MOD(%)
EQ(==), NEQ(!=), LT(<), GT(>), LE(<=), GE(>=)
AND(&&), OR(||), NOT(!)
IDENT, INTEGER_CONST
```

**语法规则层次**:
```
compUnit → decl* | funcDef*
decl → constDecl | varDecl
funcDef → funcType IDENT (funcFParams?) block
stmt → assignStmt | expStmt | blockStmt | ifStmt | whileStmt | ...
exp → addExp → mulExp → unaryExp → primaryExp
cond → lOrExp → lAndExp → eqExp → relExp → addExp
```

#### 3. AST 构建模块 (ASTBuilder)

**文件**: `src/ASTBuilder.cpp`, `include/ASTBuilder.h`

**职责**:
- 从 ANTLR 生成的 ParseTree 构建抽象语法树（AST）
- 提取和转换语法信息
- 解析字面量（十进制、八进制、十六进制整数）

**设计模式**: 递归下降构建

**主要方法**:
```cpp
class ASTBuilder {
public:
    std::unique_ptr<CompUnitNode> build(antlr4::tree::ParseTree* tree);
private:
    std::unique_ptr<CompUnitNode> buildCompUnit(SysYParser::CompUnitContext* ctx);
    std::unique_ptr<FuncDefNode> buildFuncDef(SysYParser::FuncDefContext* ctx);
    std::unique_ptr<StmtNode> buildStmt(SysYParser::StmtContext* ctx);
    std::unique_ptr<ExpNode> buildExp(SysYParser::ExpContext* ctx);
    // ... 更多构建方法
};
```

**构建流程示例**:
```
buildCompUnit()
  ├─> buildDecl() → buildConstDecl() / buildVarDecl()
  │     └─> buildConstDef() / buildVarDef()
  │           └─> buildConstInitVal() / buildInitVal()
  └─> buildFuncDef()
        ├─> buildFuncFParam()
        └─> buildBlock()
              └─> buildStmt()
                    └─> buildExp() (递归构建表达式)
```

#### 4. AST 节点定义 (Nodes)

**文件**: `include/Nodes.h`, `src/Nodes.cpp`, `include/ASTNode.h`, `include/ASTTypes.h`

**节点层次结构**:

```
ASTNode (抽象基类)
├─ CompUnitNode (编译单元)
├─ DeclNode (声明节点基类)
│  ├─ ConstDeclNode (常量声明)
│  └─ VarDeclNode (变量声明)
├─ FuncDefNode (函数定义)
├─ StmtNode (语句节点基类)
│  ├─ AssignStmtNode (赋值语句)
│  ├─ ExpStmtNode (表达式语句)
│  ├─ BlockStmtNode (块语句)
│  ├─ IfStmtNode (条件语句)
│  ├─ WhileStmtNode (循环语句)
│  ├─ BreakStmtNode (break语句)
│  ├─ ContinueStmtNode (continue语句)
│  └─ ReturnStmtNode (return语句)
└─ ExpNode (表达式节点基类)
   ├─ AddExpNode (加减表达式)
   ├─ MulExpNode (乘除模表达式)
   ├─ UnaryExpNode (一元表达式)
   ├─ PrimaryExpNode (基本表达式)
   ├─ LValNode (左值)
   ├─ NumberNode (数字字面量)
   ├─ FuncCallNode (函数调用)
   ├─ RelExpNode (关系表达式)
   ├─ EqExpNode (相等表达式)
   ├─ LAndExpNode (逻辑与表达式)
   ├─ LOrExpNode (逻辑或表达式)
   ├─ CondNode (条件表达式)
   └─ ConstExpNode (常量表达式)
```

**访问者模式接口**:
每个 AST 节点都实现 `accept()` 方法：
```cpp
class ASTNode {
public:
    virtual void accept(ASTVisitor* visitor) = 0;
    virtual std::string getNodeType() const = 0;
};
```

#### 5. 符号表模块 (SymbolTable)

**文件**: `src/SymbolTable.cpp`, `include/SymbolTable.h`, `include/SymbolEntry.h`, `include/Type.h`

**职责**:
- 管理标识符的作用域
- 存储符号信息（变量、常量、函数、参数）
- 支持嵌套作用域
- 提供符号查找功能

**核心类**:

1. **SymbolEntry (符号条目基类)**
   ```cpp
   class SymbolEntry {
       std::string name;
       SymbolType symbolType;  // VARIABLE, CONSTANT, FUNCTION, PARAMETER
       DataType dataType;      // INT, VOID, INT_ARRAY
       bool isConst;
       int scopeLevel;
   };
   ```

2. **VariableEntry (变量条目)**
   ```cpp
   class VariableEntry : public SymbolEntry {
       bool isArray;
       std::vector<int> dimensions;
       bool isInitialized;
   };
   ```

3. **FunctionEntry (函数条目)**
   ```cpp
   class FunctionEntry : public SymbolEntry {
       DataType returnType;
       std::vector<ParameterEntry*> parameters;
       SymbolTable* localSymbolTable;
   };
   ```

4. **SymbolTable (符号表)**
   ```cpp
   class SymbolTable {
       std::unordered_map<std::string, std::unique_ptr<SymbolEntry>> symbols;
       SymbolTable* parent;
       int scopeLevel;
   public:
       bool insert(std::unique_ptr<SymbolEntry> entry);
       SymbolEntry* lookup(const std::string& name);
       SymbolEntry* lookupAll(const std::string& name);  // 包含父作用域
   };
   ```

5. **SymbolTableManager (符号表管理器)**
   ```cpp
   class SymbolTableManager {
       std::unique_ptr<SymbolTable> globalTable;
       SymbolTable* currentTable;
       SymbolTable* functionTable;
   public:
       void enterScope();
       void exitScope();
       void enterFunction(FunctionEntry* func);
       void exitFunction();
       SymbolEntry* lookup(const std::string& name);
   };
   ```

**作用域管理**:
- **全局作用域**: 所有全局变量、常量和函数定义
- **函数作用域**: 函数参数和局部变量
- **块作用域**: 代码块内的局部变量
- **查找规则**: 从当前作用域向外层逐级查找

#### 6. 语义分析模块 (SemanticAnalyzer)

**文件**: `src/SemanticAnalyzer.cpp`, `include/SemanticAnalyzer.h`, `include/ASTVisitor.h`

**职责**:
- 遍历 AST 并构建符号表
- 进行类型检查
- 验证语义正确性
- 常量表达式求值

**设计模式**: 访问者模式 (Visitor Pattern)

**主要功能**:

1. **符号表构建**
   - 检查变量/函数重复定义
   - 检查变量/函数未定义引用
   - 管理作用域的进入和退出

2. **类型检查**
   - 表达式类型检查
   - 函数返回类型检查
   - 函数参数类型和数量匹配检查
   - 数组维度检查

3. **语义验证**
   - `break`/`continue` 必须在循环内
   - `void` 函数不能有返回值
   - `int` 函数必须有返回值
   - 常量必须初始化
   - 数组索引必须是整数

4. **常量表达式求值**
   ```cpp
   int evaluateConstExp(ConstExpNode* node);
   int evaluateAddExp(AddExpNode* node);
   int evaluateMulExp(MulExpNode* node);
   int evaluateUnaryExp(UnaryExpNode* node);
   ```

**访问方法**:
```cpp
class SemanticAnalyzer : public ASTVisitor {
public:
    void visitCompUnit(CompUnitNode* node) override;
    void visitConstDecl(ConstDeclNode* node) override;
    void visitVarDecl(VarDeclNode* node) override;
    void visitFuncDef(FuncDefNode* node) override;
    void visitIfStmt(IfStmtNode* node) override;
    void visitWhileStmt(WhileStmtNode* node) override;
    void visitAddExp(AddExpNode* node) override;
    // ... 更多访问方法
};
```

#### 7. 代码生成模块 (CodeGenerator)

**文件**: `src/CodeGenerator.cpp`, `include/CodeGenerator.h`

**职责**:
- 遍历 AST 生成 LLVM IR 文本
- 管理临时变量和标签
- 处理控制流（条件跳转、循环）
- 生成系统函数声明

**设计模式**: 访问者模式 (Visitor Pattern)

**关键特性**:

1. **不依赖 LLVM 库**
   - 直接生成 LLVM IR 文本格式
   - 使用 `std::ostringstream` 构建 IR 代码

2. **标签和变量管理**
   ```cpp
   int labelCounter;  // 生成唯一标签
   std::string generateLabel(const std::string& prefix);
   std::string generateVarName(const std::string& name);
   ```

3. **控制流管理**
   ```cpp
   std::string currentBreakTarget;     // 当前循环的 break 目标
   std::string currentContinueTarget;  // 当前循环的 continue 目标
   ```

4. **系统函数声明**
   ```llvm
   declare i32 @getint()
   declare i32 @getch()
   declare i32 @getarray(i32*)
   declare void @putint(i32)
   declare void @putch(i32)
   declare void @putarray(i32, i32*)
   declare void @starttime()
   declare void @stoptime()
   ```

**代码生成流程**:

1. **全局变量**
   ```cpp
   // 输入: int a = 10;
   // 输出: @a = dso_local global i32 10
   ```

2. **全局数组**
   ```cpp
   // 输入: int arr[3] = {1, 2, 3};
   // 输出: @arr = dso_local global [3 x i32] [i32 1, i32 2, i32 3]
   ```

3. **函数定义**
   ```cpp
   // 输入: int add(int a, int b) { return a + b; }
   // 输出:
   define i32 @add(i32 %a, i32 %b) {
   entry:
     %0 = alloca i32
     %1 = alloca i32
     store i32 %a, i32* %0
     store i32 %b, i32* %1
     %2 = load i32, i32* %0
     %3 = load i32, i32* %1
     %4 = add i32 %2, %3
     ret i32 %4
   }
   ```

4. **控制流 (if 语句)**
   ```cpp
   // 输入: if (a > 0) { ... } else { ... }
   // 输出:
   %cond = icmp sgt i32 %a, 0
   br i1 %cond, label %then, label %else
   then:
     ...
     br label %merge
   else:
     ...
     br label %merge
   merge:
     ...
   ```

5. **控制流 (while 循环)**
   ```cpp
   // 输入: while (i < 10) { ... }
   // 输出:
   br label %cond
   cond:
     %i_val = load i32, i32* %i
     %cmp = icmp slt i32 %i_val, 10
     br i1 %cmp, label %body, label %end
   body:
     ...
     br label %cond
   end:
     ...
   ```

6. **表达式计算**
   ```cpp
   // 输入: a + b * c
   // 输出:
   %b_val = load i32, i32* %b
   %c_val = load i32, i32* %c
   %mul = mul i32 %b_val, %c_val
   %a_val = load i32, i32* %a
   %add = add i32 %a_val, %mul
   ```

---

## 项目结构

```
thss-2025-compiler-final/
├── CMakeLists.txt           # CMake 构建配置
├── Makefile                 # 顶层 Makefile
├── README.md                # 项目说明
├── LICENSE                  # MIT 许可证
├── package.py               # 打包脚本
├── run-test.py              # 测试运行脚本
├── SysYLexer.g4             # 词法规则（ANTLR4）
├── SysYParser.g4            # 语法规则（ANTLR4）
│
├── include/                 # 头文件目录
│   ├── ASTBuilder.h         # AST 构建器
│   ├── ASTNode.h            # AST 节点基类
│   ├── ASTTypes.h           # AST 类型定义
│   ├── ASTVisitor.h         # 访问者模式接口
│   ├── CodeGenerator.h      # 代码生成器
│   ├── Compiler.h           # 编译器主类
│   ├── Nodes.h              # AST 节点定义
│   ├── SemanticAnalyzer.h   # 语义分析器
│   ├── SymbolEntry.h        # 符号表条目
│   ├── SymbolTable.h        # 符号表
│   └── Type.h               # 类型系统
│
├── src/                     # 源代码目录
│   ├── main.cpp             # 主程序入口
│   ├── Compiler.cpp         # 编译器实现
│   ├── ASTBuilder.cpp       # AST 构建器实现
│   ├── Nodes.cpp            # AST 节点实现
│   ├── SemanticAnalyzer.cpp # 语义分析器实现
│   ├── CodeGenerator.cpp    # 代码生成器实现
│   ├── SymbolTable.cpp      # 符号表实现
│   └── antlr/               # ANTLR 生成的文件
│       ├── SysYLexer.cpp
│       ├── SysYLexer.h
│       ├── SysYParser.cpp
│       ├── SysYParser.h
│       └── ...
│
├── lib/                     # 第三方库
│   └── antlr-4.13.1-complete.jar
│
├── third_party/             # 第三方依赖
│   └── antlr4-runtime/      # ANTLR4 C++ 运行时
│
├── test/                    # 测试文件
│   └── resources/
│       └── functional/      # 功能测试用例
│           ├── *.sy         # SysY 源代码
│           ├── *.ll         # 期望的 LLVM IR
│           ├── *.out        # 期望的输出
│           └── *.output     # 实际的输出
│
├── build/                   # 构建目录
│   ├── bin/                 # 可执行文件
│   ├── lib/                 # 库文件
│   └── ...
│
└── doc/                     # 文档目录
    ├── AST节点类型设计.md
    ├── 从ParseTree到LLVM IR的完整调用流程.md
    ├── 符号表类型设计.md
    └── 说明文档.md          # 本文档
```

---

## 构建和使用

### 环境依赖

**系统要求**:
- Linux (推荐 Ubuntu 20.04+)
- GCC 7+ 或 Clang 6+ (支持 C++17)
- CMake 3.10+
- Python 3.6+
- Java 11+ (用于运行 ANTLR4)

**安装依赖 (Ubuntu/Debian)**:
```bash
sudo apt update
sudo apt install build-essential cmake git pkg-config python3 openjdk-11-jdk curl clang
```

### 构建步骤

#### 1. 生成 ANTLR 文件
```bash
make antlr
```
这会使用 ANTLR4 从 `SysYLexer.g4` 和 `SysYParser.g4` 生成 C++ 词法和语法分析器代码，输出到 `src/antlr/` 目录。

#### 2. 配置和构建项目
```bash
mkdir build && cd build
cmake ..
make -j8
```
或者直接使用 Makefile：
```bash
make compiler
```

构建成功后，可执行文件位于 `build/bin/compiler`。

### 使用方法

**基本用法**:
```bash
./build/bin/compiler <input-file.sy> <output-file.ll>
```

**示例**:
```bash
./build/bin/compiler test/resources/functional/00_main.sy output.ll
```

**输入文件** (`00_main.sy`):
```c
int main() {
    return 0;
}
```

**输出文件** (`output.ll`):
```llvm
declare i32 @getint()
declare i32 @getch()
declare i32 @getarray(i32*)
declare void @putint(i32)
declare void @putch(i32)
declare void @putarray(i32, i32*)
declare void @starttime()
declare void @stoptime()

define i32 @main() {
entry:
  ret i32 0
}
```

### 运行测试

**执行所有测试**:
```bash
make test
```
或者：
```bash
python3 run-test.py
```

测试脚本会：
1. 编译所有 `test/resources/functional/*.sy` 文件
2. 使用 `lli` (LLVM 解释器) 执行生成的 IR
3. 对比实际输出和期望输出 (`.out` 文件)
4. 报告测试结果

**测试用例类型**:
- 基本功能测试: 变量定义、表达式计算、函数调用
- 数组测试: 一维/多维数组声明、初始化、访问
- 控制流测试: if-else、while、break/continue
- 复杂程序测试: 递归、嵌套循环、数组操作

### 打包和提交

**生成提交包**:
```bash
python3 package.py
```
这会生成 `project.zip` 文件，包含所有必要的源代码和文档。

---

## 编译流程详解

### 完整调用链

```
main(argc, argv)
  │
  ├─ 创建 Compiler 对象
  │    ├─ 创建 ASTBuilder
  │    ├─ 创建 SymbolTableManager
  │    ├─ 创建 SemanticAnalyzer
  │    └─ 创建 CodeGenerator
  │
  └─ Compiler::compile(inputFile, outputFile)
      │
      ├─ [阶段1] parse(inputFile)
      │    ├─ 读取源文件
      │    ├─ 创建 ANTLR 输入流 (ANTLRInputStream)
      │    ├─ 创建词法分析器 (SysYLexer)
      │    ├─ 生成 Token 流 (CommonTokenStream)
      │    ├─ 创建语法分析器 (SysYParser)
      │    ├─ 调用 parser.compUnit() → 生成 ParseTree
      │    └─ ASTBuilder::build(ParseTree)
      │         └─ 递归构建 AST 节点
      │              ├─ buildCompUnit()
      │              ├─ buildDecl() / buildFuncDef()
      │              ├─ buildStmt()
      │              └─ buildExp()
      │
      ├─ [阶段2] semanticAnalysis(ast)
      │    └─ SemanticAnalyzer::analyze(CompUnitNode)
      │         └─ 访问者模式遍历 AST
      │              ├─ visitCompUnit()
      │              │    ├─ 创建全局符号表
      │              │    ├─ visitConstDecl() / visitVarDecl()
      │              │    │    └─ 插入全局变量/常量到符号表
      │              │    └─ visitFuncDef()
      │              │         ├─ 插入函数到符号表
      │              │         ├─ 进入函数作用域
      │              │         ├─ visitFuncFParam()
      │              │         │    └─ 插入参数到符号表
      │              │         ├─ visitBlockStmt()
      │              │         │    ├─ 进入块作用域
      │              │         │    ├─ visitBlockItem()
      │              │         │    │    ├─ visitDecl() (局部声明)
      │              │         │    │    └─ visitStmt() (语句)
      │              │         │    └─ 退出块作用域
      │              │         └─ 退出函数作用域
      │              │
      │              ├─ visitStmt() (各种语句)
      │              │    ├─ visitAssignStmt()
      │              │    ├─ visitIfStmt()
      │              │    ├─ visitWhileStmt()
      │              │    └─ visitReturnStmt()
      │              │
      │              └─ visitExp() (各种表达式)
      │                   ├─ visitAddExp()
      │                   ├─ visitMulExp()
      │                   ├─ visitUnaryExp()
      │                   ├─ visitLVal()
      │                   │    └─ 检查变量是否已定义
      │                   └─ visitFuncCall()
      │                        └─ 检查函数是否已定义
      │                        └─ 检查参数类型和数量
      │
      ├─ [阶段3] generateCode(ast)
      │    └─ CodeGenerator::generate(CompUnitNode)
      │         ├─ 生成系统函数声明
      │         └─ 访问者模式遍历 AST
      │              ├─ visitCompUnit()
      │              │    ├─ visitVarDecl()
      │              │    │    └─ 生成全局变量/数组 IR
      │              │    └─ visitFuncDef()
      │              │         ├─ 生成函数签名
      │              │         ├─ 创建入口基本块
      │              │         ├─ visitFuncFParam()
      │              │         │    └─ 生成参数 alloca 和 store
      │              │         └─ visitBlockStmt()
      │              │              └─ 生成函数体 IR
      │              │
      │              ├─ visitStmt() (各种语句)
      │              │    ├─ visitAssignStmt()
      │              │    │    └─ 生成 store 指令
      │              │    ├─ visitIfStmt()
      │              │    │    ├─ 计算条件表达式
      │              │    │    ├─ 生成条件跳转 (br)
      │              │    │    ├─ 生成 then 分支
      │              │    │    ├─ 生成 else 分支
      │              │    │    └─ 生成 merge 标签
      │              │    ├─ visitWhileStmt()
      │              │    │    ├─ 生成 cond 标签
      │              │    │    ├─ 计算循环条件
      │              │    │    ├─ 生成条件跳转
      │              │    │    ├─ 生成 body 标签
      │              │    │    └─ 生成 end 标签
      │              │    ├─ visitBreakStmt()
      │              │    │    └─ 生成跳转到 end 标签
      │              │    ├─ visitContinueStmt()
      │              │    │    └─ 生成跳转到 cond 标签
      │              │    └─ visitReturnStmt()
      │              │         └─ 生成 ret 指令
      │              │
      │              └─ visitExp() (各种表达式)
      │                   ├─ visitAddExp()
      │                   │    └─ 生成 add/sub 指令
      │                   ├─ visitMulExp()
      │                   │    └─ 生成 mul/sdiv/srem 指令
      │                   ├─ visitUnaryExp()
      │                   │    └─ 生成 neg/not 指令
      │                   ├─ visitRelExp()
      │                   │    └─ 生成 icmp 指令
      │                   ├─ visitLAndExp()
      │                   │    └─ 生成短路求值 IR
      │                   ├─ visitLOrExp()
      │                   │    └─> 生成短路求值 IR
      │                   ├─ visitLVal()
      │                   │    ├─ 变量: 生成 load 指令
      │                   │    └─ 数组: 生成 getelementptr + load
      │                   └─ visitFuncCall()
      │                        ├─ 计算参数表达式
      │                        └─ 生成 call 指令
      │
      └─ [阶段4] outputIR(outputFile, irCode)
           └─ 将 IR 文本写入文件
```

### 关键数据流

1. **符号表的传递**:
   - `Compiler` 创建 `SymbolTableManager`
   - 传递给 `SemanticAnalyzer` 和 `CodeGenerator`
   - 语义分析阶段填充符号表
   - 代码生成阶段查询符号表

2. **AST 的生命周期**:
   - `parse()` 阶段创建 AST
   - `semanticAnalysis()` 阶段遍历 AST（只读）
   - `generateCode()` 阶段遍历 AST（只读）
   - 使用智能指针自动管理内存

3. **错误处理**:
   - 词法/语法错误: ANTLR 自动报告
   - 语义错误: `SemanticAnalyzer` 报告
   - 代码生成错误: `CodeGenerator` 报告

---

## 设计特点和亮点

### 1. 模块化设计

**优点**:
- 各个模块职责清晰，易于理解和维护
- 符合单一职责原则（SRP）
- 便于扩展和修改

**模块划分**:
```
编译器 = 词法分析 + 语法分析 + AST构建 + 语义分析 + 代码生成
```

### 2. 访问者模式 (Visitor Pattern)

**应用场景**:
- 语义分析器（`SemanticAnalyzer`）
- 代码生成器（`CodeGenerator`）

**优点**:
- 将算法与数据结构分离
- 易于添加新的遍历操作
- 无需修改 AST 节点类

**实现**:
```cpp
// 访问者接口
class ASTVisitor {
public:
    virtual void visitCompUnit(CompUnitNode* node) = 0;
    virtual void visitFuncDef(FuncDefNode* node) = 0;
    // ... 更多访问方法
};

// AST 节点实现
class FuncDefNode : public ASTNode {
public:
    void accept(ASTVisitor* visitor) override {
        visitor->visitFuncDef(this);
    }
};

// 具体访问者
class SemanticAnalyzer : public ASTVisitor {
public:
    void visitFuncDef(FuncDefNode* node) override {
        // 语义分析逻辑
    }
};
```

### 3. 智能指针管理内存

**使用场景**:
- AST 节点使用 `std::unique_ptr`
- 符号表条目使用 `std::unique_ptr`

**优点**:
- 自动内存管理，避免内存泄漏
- 明确所有权语义
- 无需手动 delete

**示例**:
```cpp
std::vector<std::unique_ptr<DeclNode>> decls;
std::unique_ptr<CompUnitNode> ast = parse(inputFile);
```

### 4. 符号表嵌套作用域设计

**特点**:
- 支持多层嵌套作用域
- 父子链接实现作用域查找
- 管理器统一管理作用域进入和退出

**查找策略**:
```cpp
SymbolEntry* SymbolTable::lookupAll(const std::string& name) const {
    // 先在当前作用域查找
    auto it = symbols.find(name);
    if (it != symbols.end()) {
        return it->second.get();
    }
    // 未找到则递归查找父作用域
    if (parent) {
        return parent->lookupAll(name);
    }
    return nullptr;
}
```

### 5. 不依赖 LLVM 库的 IR 生成

**特点**:
- 直接生成 LLVM IR 文本格式
- 使用 `std::ostringstream` 构建 IR
- 无需链接庞大的 LLVM 库

**优点**:
- 编译速度快
- 可执行文件体积小
- 易于理解和调试

**缺点**:
- 无法使用 LLVM 的优化 Pass
- 需要手动管理 IR 格式正确性

### 6. ANTLR4 强类型 Context

**特点**:
- 使用 ANTLR4 生成的强类型 Context 类
- 提供访问器方法直接获取子节点

**优点**:
- 类型安全
- 代码可读性高
- IDE 自动补全支持

**示例**:
```cpp
// 不使用强类型 (通用 ParseTree)
auto children = ctx->children;
for (auto child : children) {
    // 需要手动判断类型和转换
}

// 使用强类型 Context
for (auto* declCtx : ctx->decl()) {
    // 直接获取 DeclContext*，类型安全
    node->decls.push_back(buildDecl(declCtx));
}
```

### 7. 常量表达式编译时求值

**实现**:
- 在语义分析阶段对 `ConstExpNode` 求值
- 支持算术运算和常量折叠
- 用于数组维度和全局常量初始化

**示例**:
```cpp
const int SIZE = 10 + 5;  // 编译时求值为 15
int arr[SIZE];            // 数组大小为 15
```

---

## 测试用例分析

### 测试覆盖范围

项目包含丰富的功能测试用例，位于 `test/resources/functional/` 目录。

**测试分类**:

1. **基础测试** (00-09)
   - `00_main.sy`: 最简单的 main 函数
   - `01_var_defn2.sy`: 变量定义和初始化
   - `02_var_defn3.sy`: 多变量声明
   - `04_arr_defn3.sy`: 数组定义

2. **表达式测试** (10-39)
   - `36_op_priority2.sy`: 运算符优先级
   - 算术、关系、逻辑运算符测试

3. **控制流测试** (40-59)
   - if-else 语句
   - while 循环
   - break/continue 语句

4. **函数测试** (60-79)
   - `73_int_io.sy`: 输入输出函数
   - 函数定义、调用、递归

5. **数组测试** (80-99)
   - 一维、多维数组
   - 数组初始化
   - 数组元素访问

6. **综合测试**
   - `62_percolation.sy`: 复杂算法实现
   - `63_big_int_mul.sy`: 大整数运算

### 测试方法

**运行单个测试**:
```bash
./build/bin/compiler test/resources/functional/00_main.sy output.ll
lli output.ll
```

**运行所有测试**:
```bash
python3 run-test.py
```

**测试流程**:
1. 编译 `.sy` 文件生成 `.ll` 文件
2. 使用 `lli` 执行 LLVM IR
3. 对比输出和 `.out` 期望文件
4. 报告通过/失败

---

## 常见问题和注意事项

### 编译问题

**Q: ANTLR 文件未生成？**
A: 先运行 `make antlr` 生成词法和语法分析器。

**Q: 找不到 ANTLR 运行时头文件？**
A: 确保 `third_party/antlr4-runtime/` 存在且完整。

**Q: C++17 特性不支持？**
A: 升级编译器到 GCC 7+ 或 Clang 6+。

### 运行时问题

**Q: 生成的 IR 无法运行？**
A: 使用 `lli output.ll` 检查 IR 是否有语法错误。

**Q: 系统函数未定义？**
A: 确保代码生成器生成了系统函数声明。

### 测试问题

**Q: 测试失败？**
A: 检查生成的 `.output` 文件和期望的 `.out` 文件差异。

**Q: 部分测试超时？**
A: 可能是生成的代码存在死循环或效率问题。

---

## 扩展和改进建议

### 可能的扩展方向

1. **支持更多数据类型**
   - `float`, `double`
   - `char`, `string`
   - 结构体 `struct`

2. **支持更多语法特性**
   - `for` 循环
   - `switch-case` 语句
   - 指针
   - 动态内存分配

3. **优化**
   - 常量传播
   - 死代码消除
   - 循环优化
   - 使用 LLVM 优化 Pass

4. **错误处理改进**
   - 更详细的错误信息
   - 错误恢复机制
   - 警告系统

5. **调试支持**
   - 生成调试信息（DWARF）
   - 支持 GDB 调试
   - AST 可视化

### 代码质量改进

1. **单元测试**
   - 为各个模块添加单元测试
   - 使用 Google Test 框架

2. **代码规范**
   - 统一命名规范
   - 添加更多代码注释
   - 使用 clang-format 格式化

3. **性能优化**
   - 减少不必要的内存分配
   - 优化符号表查找（使用哈希表）
   - 并行化编译流程

---

## 参考资料

### SysY 语言规范
- SysY 语言定义文档
- ANTLR4 官方文档: https://www.antlr.org/
- ANTLR4 C++ Target: https://github.com/antlr/antlr4/blob/master/doc/cpp-target.md

### LLVM IR 参考
- LLVM Language Reference Manual: https://llvm.org/docs/LangRef.html
- LLVM IR Tutorial: https://llvm.org/docs/tutorial/
- LLVM Programmer's Manual: https://llvm.org/docs/ProgrammersManual.html

### 编译原理资源
- 《编译原理》（龙书）- Alfred V. Aho 等著
- 《Modern Compiler Implementation in C》- Andrew W. Appel 著
- 《Engineering a Compiler》- Keith D. Cooper, Linda Torczon 著

### C++ 资源
- C++17 标准: https://en.cppreference.com/w/cpp/17
- C++ Core Guidelines: https://isocpp.github.io/CppCoreGuidelines/
- 智能指针教程: https://en.cppreference.com/w/cpp/memory

---

## 项目总结

本项目实现了一个功能完整的 SysY 编译器，采用模块化设计，使用访问者模式遍历 AST，支持变量、数组、函数、控制流等核心语言特性，能够生成正确的 LLVM IR 代码。

### 核心成果

1. **完整的编译流程**: 从源代码到 LLVM IR 的完整实现
2. **清晰的架构设计**: 模块划分合理，易于理解和扩展
3. **良好的代码质量**: 使用现代 C++ 特性，代码可读性高
4. **丰富的测试用例**: 覆盖各种语言特性和边界情况
5. **详细的文档**: 包含设计文档、流程文档和本说明文档

### 技术亮点

- 使用 ANTLR4 进行词法和语法分析
- 访问者模式实现语义分析和代码生成
- 智能指针管理内存，避免内存泄漏
- 嵌套作用域的符号表设计
- 不依赖 LLVM 库的 IR 生成

### 学习价值

通过本项目，可以深入理解：
- 编译器的基本原理和实现技术
- 词法分析、语法分析、语义分析、代码生成各阶段的职责
- 抽象语法树（AST）的设计和遍历
- 符号表和类型系统的实现
- LLVM IR 的结构和生成方法
- 现代 C++ 编程技巧和设计模式

---

## 联系方式

如有问题或建议，请联系项目维护者或提交 Issue。

**项目仓库**: https://github.com/ForestHYS/thss-2025-compiler-final

---

*本文档最后更新时间: 2025年12月11日*
